
// ********************************************************
// simulation logging

#define _SAMPLE_LOG_LEVEL             (1 << 0)
#define _SEGMENT_LOG_LEVEL            (1 << 1)
#define _PATH_LOG_LEVEL               (1 << 2)
#define _SIMULATION_LOG_LEVEL         (1 << 3)
#define _WARNING_LOG_LEVEL            (1 << 4)
#define _ERROR_LOG_LEVEL              (1 << 5)
#define _NO_ERROR_TERMINATE_LOG_LEVEL (1 << 6)
#define _ALL_LOG_LEVELS        _SAMPLE_LOG_LEVEL|_SEGMENT_LOG_LEVEL|_PATH_LOG_LEVEL|_SIMULATION_LOG_LEVEL|_WARNING_LOG_LEVEL|_ERROR_LOG_LEVEL|_NO_ERROR_TERMINATE_LOG_LEVEL
#define _LOG_LEVELS_BEING_LOGGED (_ALL_LOG_LEVELS)

#define real Re
#define imag Im

#include <complex>

#undef real
#undef imag


#include <stdio.h>

#define _LOG(logLevel, ...) \
  do { \
    if (logLevel & _LOG_LEVELS_BEING_LOGGED) { \
      if (logLevel & (_ERROR_LOG_LEVEL | _WARNING_LOG_LEVEL)) \
          printf("%s:%i: ", __FILE__, __LINE__); \
      printf(__VA_ARGS__); \
      fflush(stdout); \
      if (logLevel & (_ERROR_LOG_LEVEL | _NO_ERROR_TERMINATE_LOG_LEVEL)) \
        exit(logLevel == _ERROR_LOG_LEVEL); \
    } \
  } while (0)

// ********************************************************
// simulation includes

#include <xpdeint_platform.h>
#include <cmath>
#include <string>
#include <cstring>
#include <fstream>
#include <sstream>
#include <cstdlib>

#if CFG_OSAPI == CFG_OSAPI_POSIX // These are POSIX headers (i.e. non-windows)
  #include <sys/time.h>
#endif // POSIX

#ifdef __APPLE__
  #include <Availability.h>
  #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
    #define OS_OBJECT_USE_OBJC 0 // Don't make dispatch and xpc objects Objective-C objects.
    #include <IOKit/pwr_mgt/IOPMLib.h> // To disable user idle sleep on Mountain Lion
  #endif
#endif

#include <time.h>
#include <list>
#include <vector>
#include <algorithm>

#include <utility>
#include <map>

#include <getopt.h>

#define DSFMT_DO_NOT_USE_OLD_NAMES
#if CFG_HAVE_SSE2
  #define HAVE_SSE2
#elif CFG_HAVE_ALTIVEC
  #define HAVE_ALTIVEC
#endif

#define DSFMT_MEXP 19937

#include <dSFMT/dSFMT.h>
#include <dSFMT/dSFMT.c>

#define H5_USE_16_API
#include <hdf5.h>

#if !defined(HAVE_H5LEXISTS)
htri_t H5Lexists(hid_t loc_id, const char *name, hid_t lapl_id)
{
  H5E_auto_t error_func;
  void* error_client_data;
  // Squelch errors generated by H5Gget_objinfo. It will report errors when it can't find an object
  // but that's the purpose of calling it.
  H5Eget_auto(&error_func, &error_client_data);
  H5Eset_auto(NULL, NULL);
  herr_t err = H5Gget_objinfo(loc_id, name, false, NULL);
  H5Eset_auto(error_func, error_client_data);
  if (err >= 0)
    return true;
  else
    return false;
}
#endif

#define H5T_NATIVE_REAL H5T_NATIVE_DOUBLE
#if defined(HAVE_HDF5_HL)
  #include <hdf5_hl.h>
#endif


typedef long integer;
typedef double real;
typedef std::complex<real> XMDSComplexType;

#include <xpdeint.h>

#define complex XMDSComplexType

const complex i(0.0, 1.0);

using namespace std;

#if CFG_COMPILER == CFG_COMPILER_ICC
  //
  // Disable ICC's warning: label was declared but never referenced
  //
  #pragma warning ( disable : 177 )
#endif

inline void *xmds_malloc(size_t size);

// ********************************************************
// DEFINES
// ********************************************************

// ********************************************************
//   Simulation defines
#define _EPSILON 1e-6
#ifndef INFINITY
#define INFINITY HUGE_VAL
#endif

#ifndef MAX
#define MAX(a, b) \
  ({ typeof(a) _a = (a); \
     typeof(b) _b = (b); \
     _a > _b ? _a : _b; })
#endif

#ifndef MIN
#define MIN(a, b) \
   ({ typeof(a) _a = (a); \
      typeof(b) _b = (b); \
      _a < _b ? _a : _b; })
#endif


// ********************************************************
//   Auto-vectorisation defines

#define _MAKE_AUTOVEC_VARIABLE(x) real* const __restrict__ x ## _autovec = (real*) x
#define _AUTOVEC(x) (x ## _autovec)

// ********************************************************
//   Geometry defines
#define _lattice_j ((int)N)
#define _min_j     ((long)1)
#define _max_j     ((long)N)
#define _dj        ((long)1)

// ********************************************************
//   field j defines
#define _j_ndims 1


// vector QNoise defines
#define _j_QNoise_ncomponents 2

// vector hoppings defines
#define _j_hoppings_ncomponents 2

// vector wavefunction defines
#define _j_wavefunction_ncomponents 2

// ********************************************************
//   segment 1 (RK4 fixed-step integrator) defines
// vector wavefunction defines
#define _segment1_operator0_delta_a_field_wavefunction_ncomponents 2

// ********************************************************
//   field mg0_sampling defines
#define _mg0_sampling_ndims 1


// ********************************************************
//   field mg0_output defines
#define _mg0_output_ndims 2


#define _mg0_output_lattice_t ((int)1001)
#define _mg0_output_min_t     (_mg0_output_t[0])
#define _mg0_output_max_t     (_mg0_output_t[_mg0_output_lattice_t-1])
#define _mg0_output_dt        (_mg0_output_t[_index_t+1]-_mg0_output_t[_index_t])

// vector raw defines
#define _mg0_output_raw_ncomponents 4

// ********************************************************
//   field segment1_operator0_looping_field defines
#define _segment1_operator0_looping_field_ndims 1


// ********************************************************
//   field segment1_operator0_delta_a_field defines
#define _segment1_operator0_delta_a_field_ndims 1



// ********************************************************
// GLOBALS
// ********************************************************


// ********************************************************
//   Simulation globals

string gsArgsAndValues = "";
  
real t;

// ********************************************************
//   Transform Multiplexer globals
typedef pair<ptrdiff_t, ptrdiff_t> _basis_pair;
typedef void (*transform_function)(bool, real, real* const __restrict__, real* const __restrict__, ptrdiff_t, ptrdiff_t);

// Less than operator needed by the C++ map class
struct _basis_pair_less_than
{
  bool operator()(const _basis_pair& _x, const _basis_pair& _y) const {
    return (_x.first < _y.first) || ((_x.first == _y.first) && (_x.second < _y.second));
  }
};

struct _transform_step
{
  transform_function _func;
  bool _forward;
  bool _out_of_place;
  ptrdiff_t _prefix_lattice;
  ptrdiff_t _postfix_lattice;
};

// Structure to hold the basis change information
struct _basis_transform_t
{
  vector<_transform_step> _transform_steps;
  real _multiplier;
  
  _basis_transform_t(real _multiplier_in = 1.0) : _multiplier(_multiplier_in) {}
  
  _basis_transform_t(const _basis_transform_t& _b) : _transform_steps(_b._transform_steps), _multiplier(_b._multiplier) {}
  
  void append(transform_function _func, bool _forward, bool _out_of_place, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
  {
    _transform_steps.push_back((_transform_step){_func, _forward, _out_of_place, _prefix_lattice, _postfix_lattice});
  }
};

// Map type for holding (old_basis, new_basis) -> _basis_transform_t mappings
typedef map<_basis_pair, _basis_transform_t, _basis_pair_less_than> _basis_map;


real *_auxiliary_array = NULL;

const char *_basis_identifiers[] = {
};

// ********************************************************
//   Command line argument processing globals
real Ttot = 100; 
integer N = 3; 
real Kappa = 0.5; 
real Uint = 1.5; 
real Delta = -2.0; 
real Jhop = 1.0; 
real FPmp = 1.0; 
integer seed1 = 8; 
integer seed2 = 6; 
integer seed3 = 5; 

// ********************************************************
//   Geometry globals
long* _j = NULL;

// ********************************************************
//   field j globals
// vector QNoise globals
size_t _j_QNoise_alloc_size = 0;
real* _j_QNoise = NULL;
real* _active_j_QNoise = NULL;

uint32_t _gen_QNoise_seeds[3];
dsfmt_t* _gen_QNoise;

// vector hoppings globals
size_t _j_hoppings_alloc_size = 0;
real* _j_hoppings = NULL;
real* _active_j_hoppings = NULL;

// vector wavefunction globals
size_t _j_wavefunction_alloc_size = 0;
complex* _j_wavefunction = NULL;
complex* _active_j_wavefunction = NULL;

// ********************************************************
//   segment 1 (RK4 fixed-step integrator) globals
complex* _segment1_akfield_j_wavefunction;
complex* _segment1_aifield_j_wavefunction;

// vector wavefunction globals
size_t _segment1_operator0_delta_a_field_wavefunction_alloc_size = 0;
complex* _segment1_operator0_delta_a_field_wavefunction = NULL;
complex* _active_segment1_operator0_delta_a_field_wavefunction = NULL;

// ********************************************************
//   field mg0_output globals
real* _mg0_output_t = NULL;
unsigned long _mg0_output_index_t = 0;

// vector raw globals
size_t _mg0_output_raw_alloc_size = 0;
real* _mg0_output_raw = NULL;
real* _active_mg0_output_raw = NULL;


// ********************************************************
// FUNCTION PROTOTYPES
// ********************************************************

// ********************************************************
//   Command line argument processing function prototypes
void _print_usage();

// ********************************************************
//   field j function prototypes
void _j_QNoise_evaluate(real _step);
void _j_QNoise_split(real _new_step, real _old_step, real* _old_array);

void _j_hoppings_initialise();

void _j_wavefunction_initialise();

// ********************************************************
//   segment 0 (Top level sequence) function prototypes
void _segment0();

// ********************************************************
//   segment 1 (RK4 fixed-step integrator) function prototypes
void _segment1();
inline void _segment1_calculate_delta_a(real _step);
inline void _segment1_ip_evolve(int _exponent);
inline void _segment1_calculate_nonconstant_ip_fields(real _step, int _exponent);

void _segment1_j_operators_evaluate_operator0(real _step);
inline void _segment1_j_operators_operator0_copy_delta_a(real _step);

// ********************************************************
//   output function prototypes
void _write_output();

FILE* _open_xsil_file(const char* _filename);
void _close_xsil_file(FILE*& fp);
void _write_xsil_header(FILE* fp);
void _write_xsil_footer(FILE* fp);

// ********************************************************
//   moment group 0 function prototypes
void _mg0_sample();
void _mg0_process();
void _mg0_write_out(FILE* _outfile);

// ********************************************************
//   field mg0_output function prototypes
void _mg0_output_raw_initialise();

// ********************************************************
// MAIN ROUTINE
// ********************************************************
int main(int argc, char **argv)
{
  #ifdef __APPLE__
    #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
  {
    IOPMAssertionID _powerAssertionID = 0;
    IOReturn __io_result = IOPMAssertionCreateWithDescription(
      kIOPMAssertionTypePreventUserIdleSystemSleep,
      CFSTR("XMDS simulation 'DDBH_Nsite_PP_v1' preventing user idle sleep"), // Assertion name
      NULL, // Assertion details
      NULL, // Human-readable reason
      NULL, // Localization bundle path
      (CFTimeInterval)0, // never timeout
      kIOPMAssertionTimeoutActionRelease,
      &_powerAssertionID
      );
    if (__io_result != kIOReturnSuccess) {
      _LOG(_WARNING_LOG_LEVEL, "Failed to disable user idle sleep\n");
    }
    // Note, this power assertion is automatically released when the process quits.
  }
    #endif
  #endif
  
    
  // *********** Parse the command line for arguments, and set  *********
  // *********** the appropriate global variables               *********
  
  int resp;
  std::map<string, string> mInputArgsAndValues;
  
  while (1) {
    static struct option long_options[] = 
      {
        {"help", no_argument, 0, 'h'},
        {"Ttot", required_argument, 0, 'T'},
        {"N", required_argument, 0, 'N'},
        {"Kappa", required_argument, 0, 'K'},
        {"Uint", required_argument, 0, 'U'},
        {"Delta", required_argument, 0, 'D'},
        {"Jhop", required_argument, 0, 'J'},
        {"FPmp", required_argument, 0, 'F'},
        {"seed1", required_argument, 0, 's'},
        {"seed2", required_argument, 0, 'e'},
        {"seed3", required_argument, 0, 'd'},
        {NULL, 0, 0, 0}
      };
    
    int option_index = 0;
  
    resp = getopt_long(argc, argv, "hT:N:K:U:D:J:F:s:e:d:", long_options, &option_index);
    
    if (resp == -1)
      break;
  
    switch (resp) {
      case '?':
        // An unknown option was passed. Show allowed options and exit. 
        _print_usage(); // This causes the simulation to exit
  
      case 'h':
        _print_usage(); // This causes the simulation to exit
      
      case 'T':
        Ttot = strtod(optarg, NULL);
        break;
      
      case 'N':
        N = strtol(optarg, NULL, 10);
        break;
      
      case 'K':
        Kappa = strtod(optarg, NULL);
        break;
      
      case 'U':
        Uint = strtod(optarg, NULL);
        break;
      
      case 'D':
        Delta = strtod(optarg, NULL);
        break;
      
      case 'J':
        Jhop = strtod(optarg, NULL);
        break;
      
      case 'F':
        FPmp = strtod(optarg, NULL);
        break;
      
      case 's':
        seed1 = strtol(optarg, NULL, 10);
        break;
      
      case 'e':
        seed2 = strtol(optarg, NULL, 10);
        break;
      
      case 'd':
        seed3 = strtol(optarg, NULL, 10);
        break;
        
      default:
        _LOG(_ERROR_LOG_LEVEL, "Internal error in processing arguments.\n");
    }
  }
  
  
  if (optind < argc)
    _print_usage(); // This causes the simulation to exit.
  
  // ******** Argument post-processing code *******
  // **********************************************
  
    
  
  _mg0_output_raw_alloc_size = MAX(_mg0_output_raw_alloc_size, (_mg0_output_lattice_t * _lattice_j) * _mg0_output_raw_ncomponents);
  _j_QNoise_alloc_size = MAX(_j_QNoise_alloc_size, (_lattice_j) * _j_QNoise_ncomponents);
  _j_hoppings_alloc_size = MAX(_j_hoppings_alloc_size, (_lattice_j) * _j_hoppings_ncomponents);
  _segment1_operator0_delta_a_field_wavefunction_alloc_size = MAX(_segment1_operator0_delta_a_field_wavefunction_alloc_size, (_lattice_j) * _segment1_operator0_delta_a_field_wavefunction_ncomponents);
  _j_wavefunction_alloc_size = MAX(_j_wavefunction_alloc_size, (_lattice_j) * _j_wavefunction_ncomponents);
  _j = (long*) xmds_malloc(sizeof(long) * (_lattice_j+1));
  
  _j_QNoise = (real*) xmds_malloc(sizeof(real) * MAX(_j_QNoise_alloc_size,1));
  _active_j_QNoise = _j_QNoise;
  
  
  _j_hoppings = (real*) xmds_malloc(sizeof(real) * MAX(_j_hoppings_alloc_size,1));
  _active_j_hoppings = _j_hoppings;
  
  
  _j_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_j_wavefunction_alloc_size,1));
  _active_j_wavefunction = _j_wavefunction;
  _mg0_output_t = (real*) xmds_malloc(sizeof(real) * (_mg0_output_lattice_t+1));
  
  
  _mg0_output_raw = (real*) xmds_malloc(sizeof(real) * MAX(_mg0_output_raw_alloc_size,1));
  _active_mg0_output_raw = _mg0_output_raw;
  
  
  // Run-time validation checks
  
  if (1 >= N)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The end point of the dimension 'N' must be "
                           "greater than the start point.\n"
                           "Start = %e, End = %e\n", (real)1, (real)N);
  
  if ((N) != ((N) - (1) + 1))
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The lattice value of 'N'=%li doesn't match with the domain "
                           "'1'=%li to 'N'=%li (%li lattice points).\n",
                           long(N), long(1), long(N), long((N) - (1)+1));
  
  
  if (seed1 < 0)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The seed for this noise vector is not positive!\n"
    "Seed = %d\n", seed1);
  
  if (seed2 < 0)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The seed for this noise vector is not positive!\n"
    "Seed = %d\n", seed2);
  
  if (seed3 < 0)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The seed for this noise vector is not positive!\n"
    "Seed = %d\n", seed3);
  
  if (Ttot <= 0.0)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The interval for segment 1 is not positive!\n"
                           "Interval = %e\n", Ttot);
  
  if (N > N)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: Can't sample more points in dimension 'j' than\n"
                           "there are points in the full dimension.\n"
                           "%i > %i.\n", (int)N, (int)N);
  
  if ( (N > 0) && (N % N !=0) )
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The number of sampling lattice points (%i) must divide the number\n"
                         "of lattice points on the simulation grid (%i).\n", (int)N, (int)N);
  
  for (long _index_j = 0; _index_j < _lattice_j; _index_j++)
    _j[_index_j] = _min_j + _index_j*_dj;
  _active_mg0_output_raw = _mg0_output_raw;
  _mg0_output_raw_initialise();
  
  _gen_QNoise_seeds[0] = seed1;
  _gen_QNoise_seeds[1] = seed2;
  _gen_QNoise_seeds[2] = seed3;
  
  
  _basis_transform_t *_basis_transform = NULL;
  ptrdiff_t _auxiliary_array_size = 0;
  ptrdiff_t _max_vector_size = 0;
  real* _max_vector_array = NULL;
  
  if (_auxiliary_array_size) {
    _auxiliary_array = (real*) xmds_malloc(sizeof(real) * _auxiliary_array_size);
  }
  
  bool _allocated_temporary_array = false;
  if (!_max_vector_array && _max_vector_size > 0) {
    _max_vector_array = (real*) xmds_malloc(sizeof(real) * _max_vector_size);
    _allocated_temporary_array = true;
  }
  
  // Make all geometry-dependent transformations prepare plans, etc.
  
  if (_allocated_temporary_array) {
    xmds_free(_max_vector_array);
  }
  
  // Get the time at which the simulation started
  timeval _tim;
  gettimeofday(&_tim, NULL);
  double _startTime = _tim.tv_sec + (_tim.tv_usec/1e6);
  
  /* Code that actually does stuff goes here */
  _segment0();
  
  
  _write_output();
  
  // Work out how long the simulation has run for
  gettimeofday(&_tim, NULL);
  double _endTime = _tim.tv_sec + (_tim.tv_usec/1e6);
  _LOG(_SIMULATION_LOG_LEVEL, "Time elapsed for simulation is: %.2f seconds\n", _endTime - _startTime);
  if (_auxiliary_array) {
    xmds_free(_auxiliary_array);
  }
  
  // Bing!
  _LOG(_SIMULATION_LOG_LEVEL, "\a");
  
  xmds_free(_j_QNoise);
  _active_j_QNoise = _j_QNoise = NULL;
  
  
  xmds_free(_j_hoppings);
  _active_j_hoppings = _j_hoppings = NULL;
  
  
  xmds_free(_j_wavefunction);
  _active_j_wavefunction = _j_wavefunction = NULL;
  
  xmds_free(_mg0_output_raw);
  _active_mg0_output_raw = _mg0_output_raw = NULL;
  
  
  return 0;
}

// ********************************************************
// FUNCTION IMPLEMENTATIONS
// ********************************************************

inline void *xmds_malloc(size_t size)
{
  void *retPointer = _xmds_malloc(size);
  if ( !retPointer )
    _LOG(_ERROR_LOG_LEVEL, "ERROR: Couldn't allocate %zu bytes of memory!", size);
  return retPointer;
}


// ********************************************************
//   Command line argument processing function implementations
void _print_usage()
{
  // This function does not return.
  _LOG(_NO_ERROR_TERMINATE_LOG_LEVEL, "\n\nUsage: DDBH_Nsite_PP_v1 --Ttot <real> --N <integer> --Kappa <real> --Uint <real> --Delta <real> --Jhop <real> --FPmp <real> --seed1 <integer> --seed2 <integer> --seed3 <integer>\n\n"
                         "Details:\n"
                         "Option\t\tType\t\tDefault value\n"
                         "-T,  --Ttot\treal \t\t100\n"
                         "-N,  --N\tinteger \t\t3\n"
                         "-K,  --Kappa\treal \t\t0.5\n"
                         "-U,  --Uint\treal \t\t1.5\n"
                         "-D,  --Delta\treal \t\t-2.0\n"
                         "-J,  --Jhop\treal \t\t1.0\n"
                         "-F,  --FPmp\treal \t\t1.0\n"
                         "-s,  --seed1\tinteger \t\t8\n"
                         "-e,  --seed2\tinteger \t\t6\n"
                         "-d,  --seed3\tinteger \t\t5\n"
                         );
  // _LOG terminates the simulation.
}

// ********************************************************
//   Default Simulation Driver function implementations
void _segment0()
{
  
  
  uint32_t _gen_QNoise_local_seeds[3] = {
  _gen_QNoise_seeds[0]+(0)*1,
  _gen_QNoise_seeds[1]+(0)*2,
  _gen_QNoise_seeds[2]+(0)*3
  };
  
  
  _gen_QNoise = (dsfmt_t *)xmds_malloc(sizeof(dsfmt_t));
  dsfmt_init_by_array(_gen_QNoise, _gen_QNoise_local_seeds, 3);
  
  t = 0.0;
  
  _mg0_output_raw_initialise();
  _active_j_hoppings = _j_hoppings;
  _j_hoppings_initialise();
  _active_j_wavefunction = _j_wavefunction;
  _j_wavefunction_initialise();
  _mg0_output_index_t = 0;
  _mg0_sample();
  _segment1();
  
  _mg0_process();
}


// ********************************************************
//   field j function implementations
void _j_QNoise_evaluate(real _step)
{
  const ptrdiff_t _vector_size = (_lattice_j) * _j_QNoise_ncomponents;
  const real _var = 1.0 / (1.0* _step);
  
  const ptrdiff_t _evenNoises = _vector_size & ~1;
  for (ptrdiff_t _i0 = 0; _i0 < _evenNoises; _i0 += 2) {
    real _v1, _v2, _rsq;
    do {
      _v1 = (2.0*dsfmt_genrand_close1_open2(_gen_QNoise) - 3.0);
      _v2 = (2.0*dsfmt_genrand_close1_open2(_gen_QNoise) - 3.0);
      _rsq = _v1*_v1 + _v2*_v2;
    } while(_rsq >= 1.0 || _rsq == 0.0);
    const real _fac = sqrt(-2.0*_var*log(_rsq)/_rsq);
    reinterpret_cast<real*>(_active_j_QNoise)[_i0 + 0] = _v1*_fac;
    reinterpret_cast<real*>(_active_j_QNoise)[_i0 + 1] = _v2*_fac;
  }
  
  // If _n is odd, we need to generate the last random number
  if (_vector_size & 1) {
    static real _spareNoise = 0.0;
    static bool _spareNoiseAvailable = false;
    static real _old_var = 0.0;
    
    if (_spareNoiseAvailable && _old_var == _var) {
      reinterpret_cast<real*>(_active_j_QNoise)[_vector_size - 1] = _spareNoise;
      _spareNoiseAvailable = false;
    } else {
      real _v1, _v2, _rsq;
      do {
        _v1 = (2.0*dsfmt_genrand_close1_open2(_gen_QNoise) - 3.0);
        _v2 = (2.0*dsfmt_genrand_close1_open2(_gen_QNoise) - 3.0);
        _rsq = _v1*_v1 + _v2*_v2;
      } while(_rsq >= 1.0 || _rsq == 0.0);
      const real _fac = sqrt(-2.0*_var*log(_rsq)/_rsq);
      reinterpret_cast<real*>(_active_j_QNoise)[_vector_size - 1] = _v1*_fac;
      _spareNoise = _v2*_fac;
      
      _spareNoiseAvailable = true;
      _old_var = _var;
    }
  }
}


void _j_QNoise_split(real _new_step, real _old_step, real* _old_array)
{
  const ptrdiff_t _vector_size = (_lattice_j) * _j_QNoise_ncomponents;
  // Split a gaussian noise
  _j_QNoise_evaluate((_new_step * _old_step)/(_old_step - _new_step));
  
  // Now complete creation of the new noise.
  
  {
    _MAKE_AUTOVEC_VARIABLE(_old_array);
    _MAKE_AUTOVEC_VARIABLE(_active_j_QNoise);
    #pragma ivdep
    for (long _i0 = 0; _i0 < (_lattice_j) * _j_QNoise_ncomponents; _i0++) {
      _AUTOVEC(_active_j_QNoise)[_i0] += _AUTOVEC(_old_array)[_i0];
    }
  
  }
  
}

// initialisation for vector hoppings
void _j_hoppings_initialise()
{
  
  long _j_hoppings_index_pointer = 0;
  #define J_hop_plus _active_j_hoppings[_j_hoppings_index_pointer + 0]
  #define J_hop_minus _active_j_hoppings[_j_hoppings_index_pointer + 1]
  #define j _j[_index_j + 0]
  #define dj (_dj * (1.0))
  
  for (long _index_j = 0; _index_j < _lattice_j; _index_j++) {
    // The purpose of the following define is to give a (somewhat helpful) compile-time error
    // if the user has attempted to use the propagation dimension variable in the initialisation
    // block of a <vector> element. If they're trying to do this, what they really want is a 
    // <computed_vector> instead.
    #define t Dont_use_propagation_dimension_t_in_vector_element_CDATA_block___Use_a_computed_vector_instead
    
    // ********** Initialisation code ***************
    #line 87 "DDBH_Nsite_PP_v1.xmds"
    
    J_hop_plus = Jhop;
    J_hop_minus = Jhop;
    
    #line 795 "DDBH_Nsite_PP_v1.cc"
    // **********************************************
    #undef t
    
    // Increment index pointers for vectors in field j (or having the same dimensions)
    _j_hoppings_index_pointer += 1 * _j_hoppings_ncomponents;
    
  }
  #undef j
  #undef dj
  #undef J_hop_plus
  #undef J_hop_minus
}

// initialisation for vector wavefunction
void _j_wavefunction_initialise()
{
  
  long _j_wavefunction_index_pointer = 0;
  #define alpha _active_j_wavefunction[_j_wavefunction_index_pointer + 0]
  #define beta _active_j_wavefunction[_j_wavefunction_index_pointer + 1]
  #define j _j[_index_j + 0]
  #define dj (_dj * (1.0))
  
  for (long _index_j = 0; _index_j < _lattice_j; _index_j++) {
    // The purpose of the following define is to give a (somewhat helpful) compile-time error
    // if the user has attempted to use the propagation dimension variable in the initialisation
    // block of a <vector> element. If they're trying to do this, what they really want is a 
    // <computed_vector> instead.
    #define t Dont_use_propagation_dimension_t_in_vector_element_CDATA_block___Use_a_computed_vector_instead
    
    // ********** Initialisation code ***************
    #line 73 "DDBH_Nsite_PP_v1.xmds"
    
    alpha = 0;
    beta = 0;
    
    #line 832 "DDBH_Nsite_PP_v1.cc"
    // **********************************************
    #undef t
    
    // Increment index pointers for vectors in field j (or having the same dimensions)
    _j_wavefunction_index_pointer += 1 * _j_wavefunction_ncomponents;
    
  }
  #undef j
  #undef dj
  #undef alpha
  #undef beta
}

// ********************************************************
//   segment 1 (RK4 fixed-step integrator) function implementations
void _segment1()
{
  real _step = Ttot/(real)100000;
  real _noiseStep = Ttot/(real)100000;
  
  
  _segment1_operator0_delta_a_field_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_segment1_operator0_delta_a_field_wavefunction_alloc_size,1));
  _active_segment1_operator0_delta_a_field_wavefunction = _segment1_operator0_delta_a_field_wavefunction;
  _segment1_akfield_j_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_j_wavefunction_alloc_size,1));
  _segment1_aifield_j_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_j_wavefunction_alloc_size,1));
  complex* _akfield_j_wavefunction = _segment1_akfield_j_wavefunction;
  complex* _aifield_j_wavefunction = _segment1_aifield_j_wavefunction;
  
  
  for (long _istep = 0; _istep < 100000; _istep++) {
    
    _active_j_QNoise = _j_QNoise;
    _j_QNoise_evaluate(_noiseStep);
    
    
    // a_k = a
    memcpy(_akfield_j_wavefunction, _j_wavefunction, sizeof(complex) * _j_wavefunction_alloc_size);
    
    _segment1_calculate_nonconstant_ip_fields(_step, 1);
    
    // a = D[a]
    _segment1_ip_evolve(1);
    
    // a_i = a
    memcpy(_aifield_j_wavefunction, _j_wavefunction, sizeof(complex) * _j_wavefunction_alloc_size);
    
    _active_j_wavefunction = _akfield_j_wavefunction;
      
    // a_k = G[a_k, t]
    _segment1_calculate_delta_a(_step);
    
    // a_k = D[a_k]
    _segment1_ip_evolve(1);
    
    {
      _MAKE_AUTOVEC_VARIABLE(_akfield_j_wavefunction);
      _MAKE_AUTOVEC_VARIABLE(_j_wavefunction);
      _MAKE_AUTOVEC_VARIABLE(_aifield_j_wavefunction);
      #pragma ivdep
      for (long _i0 = 0; _i0 < 2 * (_lattice_j) * _j_wavefunction_ncomponents; _i0++) {
        // a = a + a_k/6
        _AUTOVEC(_j_wavefunction)[_i0] += _AUTOVEC(_akfield_j_wavefunction)[_i0]/6.0;
        // a_k = a_i + a_k/2
        _AUTOVEC(_akfield_j_wavefunction)[_i0] = _AUTOVEC(_aifield_j_wavefunction)[_i0] + 0.5*_AUTOVEC(_akfield_j_wavefunction)[_i0];
      }
    
    }
    
    t += 0.5*_step;
    
    // a_k = G[a_k, t + h/2]
    _segment1_calculate_delta_a(_step);
    
    {
      _MAKE_AUTOVEC_VARIABLE(_akfield_j_wavefunction);
      _MAKE_AUTOVEC_VARIABLE(_j_wavefunction);
      _MAKE_AUTOVEC_VARIABLE(_aifield_j_wavefunction);
      #pragma ivdep
      for (long _i0 = 0; _i0 < 2 * (_lattice_j) * _j_wavefunction_ncomponents; _i0++) {
        // a = a + a_k/3
        _AUTOVEC(_j_wavefunction)[_i0] += _AUTOVEC(_akfield_j_wavefunction)[_i0]/3.0;
        // a_k = a_i + a_k/2
        _AUTOVEC(_akfield_j_wavefunction)[_i0] = _AUTOVEC(_aifield_j_wavefunction)[_i0] + 0.5*_AUTOVEC(_akfield_j_wavefunction)[_i0];
      }
    
    }
    
    // a_k = G[a_k, t + h/2]
    _segment1_calculate_delta_a(_step);
    
    {
      _MAKE_AUTOVEC_VARIABLE(_akfield_j_wavefunction);
      _MAKE_AUTOVEC_VARIABLE(_j_wavefunction);
      _MAKE_AUTOVEC_VARIABLE(_aifield_j_wavefunction);
      #pragma ivdep
      for (long _i0 = 0; _i0 < 2 * (_lattice_j) * _j_wavefunction_ncomponents; _i0++) {
        // a = a + a_k/3
        _AUTOVEC(_j_wavefunction)[_i0] += _AUTOVEC(_akfield_j_wavefunction)[_i0]/3.0;
        // a_k = a_i + a_k
        _AUTOVEC(_akfield_j_wavefunction)[_i0] = _AUTOVEC(_aifield_j_wavefunction)[_i0] + _AUTOVEC(_akfield_j_wavefunction)[_i0];
      }
    
    }
    
    // a_k = D[a_k]
    _segment1_ip_evolve(1);
    
    t += 0.5*_step;
    
    // a_k = G[a_k, t + h]
    _segment1_calculate_delta_a(_step);
    
    _active_j_wavefunction = _j_wavefunction;
    
    // a = D[a]
    _segment1_ip_evolve(1);
    
    {
      _MAKE_AUTOVEC_VARIABLE(_akfield_j_wavefunction);
      _MAKE_AUTOVEC_VARIABLE(_j_wavefunction);
      #pragma ivdep
      for (long _i0 = 0; _i0 < 2 * (_lattice_j) * _j_wavefunction_ncomponents; _i0++) {
        // a = a + a_k/6
        _AUTOVEC(_j_wavefunction)[_i0] += _AUTOVEC(_akfield_j_wavefunction)[_i0]/6.0;
      }
    
    }
    // Check if a component of any integration vector is non-finite
    // no need to check all components since they will be quickly mixed
    if (_xmds_isnonfinite(_active_j_wavefunction[0].Re())) {
      // One of the integration vectors has gone non-finite.
      // Sample any moment groups that have pending samples,
      // then leave the integrator.
      _LOG(_WARNING_LOG_LEVEL, "WARNING: halt_non_finite: Integration halted at t = %e.\n"
                               "         Non-finite number in integration vector in segment 1.\n", t);
      
      if (_mg0_output_index_t < _mg0_output_lattice_t)
        _mg0_sample();
      
      goto _SEGMENT1_END;
    }
    
    if ((_istep % 100) == 99.0)
      _mg0_sample();
  }
  
  _SEGMENT1_END:;
  
  xmds_free(_segment1_operator0_delta_a_field_wavefunction);
  _active_segment1_operator0_delta_a_field_wavefunction = _segment1_operator0_delta_a_field_wavefunction = NULL;
  xmds_free(_segment1_akfield_j_wavefunction);
  xmds_free(_segment1_aifield_j_wavefunction);
  
}


inline void _segment1_calculate_delta_a(real _step)
{
  
  
  // Delta A propagation operator for field j
  _segment1_j_operators_evaluate_operator0(_step);
  
}


inline void _segment1_ip_evolve(int _exponent)
{
}


inline void _segment1_calculate_nonconstant_ip_fields(real _step, int _exponent)
{
}

// Delta A propagation operator for field j
void _segment1_j_operators_evaluate_operator0(real _step)
{
  long _j_QNoise_index_pointer = 0;
  #define XiA _active_j_QNoise[_j_QNoise_index_pointer + 0]
  #define XiB _active_j_QNoise[_j_QNoise_index_pointer + 1]
  long _j_hoppings_index_pointer = 0;
  #define J_hop_plus _active_j_hoppings[_j_hoppings_index_pointer + 0]
  #define J_hop_minus _active_j_hoppings[_j_hoppings_index_pointer + 1]
  long _segment1_operator0_delta_a_field_wavefunction_index_pointer = 0;
  #define dalpha_dt _active_segment1_operator0_delta_a_field_wavefunction[_segment1_operator0_delta_a_field_wavefunction_index_pointer + 0]
  #define dbeta_dt _active_segment1_operator0_delta_a_field_wavefunction[_segment1_operator0_delta_a_field_wavefunction_index_pointer + 1]
  long _j_wavefunction_index_pointer = 0;
  #define alpha _active_j_wavefunction[_j_wavefunction_index_pointer + 0]
  #define beta _active_j_wavefunction[_j_wavefunction_index_pointer + 1]
  #define j _j[_index_j + 0]
  #define dj (_dj * (1.0))
  
  for (long _index_j = 0; _index_j < _lattice_j; _index_j++) {
    
    #define dt _step
    
    // ************* Propagation code ***************
    #define _beta_j(_index_j) _active_j_wavefunction[1 + (0 \
       + _index_j * 1) * _j_wavefunction_ncomponents]
    #define _alpha_j(_index_j) _active_j_wavefunction[0 + (0 \
       + _index_j * 1) * _j_wavefunction_ncomponents]
    #line 117 "DDBH_Nsite_PP_v1.xmds"
    
    int j_plus = (j%N) + 1;
    int j_minus = N - (N+1-j)%N;
    
    dalpha_dt = i*Delta*alpha -Kappa*alpha -i*Uint*alpha*beta*alpha +0.5*i*Uint*alpha 
          +i*J_hop_plus*_alpha_j(/* j => j_plus */ ((j_plus) - _min_j)) +i*J_hop_minus*_alpha_j(/* j => j_minus */ ((j_minus) - _min_j)) -i*FPmp +sqrt(i*Uint)*i*alpha*XiA;
    
    dbeta_dt = -i*Delta*beta -Kappa*beta +i*Uint*beta*alpha*beta -0.5*i*Uint*beta 
          -i*J_hop_plus*_beta_j(/* j => j_plus */ ((j_plus) - _min_j)) -i*J_hop_minus*_beta_j(/* j => j_minus */ ((j_minus) - _min_j)) +i*FPmp +sqrt(i*Uint)*beta*XiB;
    
    #line 1046 "DDBH_Nsite_PP_v1.cc"
    #undef _beta_j
    #undef _alpha_j
    // **********************************************
    
    #undef dt
    
    
    // Increment index pointers for vectors in field segment1_operator0_looping_field (or having the same dimensions)
    _j_QNoise_index_pointer += 1 * _j_QNoise_ncomponents;
    _j_hoppings_index_pointer += 1 * _j_hoppings_ncomponents;
    _segment1_operator0_delta_a_field_wavefunction_index_pointer += 1 * _segment1_operator0_delta_a_field_wavefunction_ncomponents;
    _j_wavefunction_index_pointer += 1 * _j_wavefunction_ncomponents;
    
  }
  #undef j
  #undef dj
  _segment1_j_operators_operator0_copy_delta_a(_step);
  #undef XiA
  #undef XiB
  #undef J_hop_plus
  #undef J_hop_minus
  #undef dalpha_dt
  #undef dbeta_dt
  #undef alpha
  #undef beta
}


inline void _segment1_j_operators_operator0_copy_delta_a(real _step)
{
  long _segment1_operator0_delta_a_field_wavefunction_index_pointer = 0;
  #define dalpha_dt _active_segment1_operator0_delta_a_field_wavefunction[_segment1_operator0_delta_a_field_wavefunction_index_pointer + 0]
  #define dbeta_dt _active_segment1_operator0_delta_a_field_wavefunction[_segment1_operator0_delta_a_field_wavefunction_index_pointer + 1]
  long _j_wavefunction_index_pointer = 0;
  #define alpha _active_j_wavefunction[_j_wavefunction_index_pointer + 0]
  #define beta _active_j_wavefunction[_j_wavefunction_index_pointer + 1]
  #define j _j[_index_j + 0]
  #define dj (_dj * (1.0))
  
  for (long _index_j = 0; _index_j < _lattice_j; _index_j++) {
    // This code copies the increments for the components back into the vectors themselves.
    alpha = dalpha_dt * _step;
    beta = dbeta_dt * _step;
    // Increment index pointers for vectors in field segment1_operator0_looping_field (or having the same dimensions)
    _segment1_operator0_delta_a_field_wavefunction_index_pointer += 1 * _segment1_operator0_delta_a_field_wavefunction_ncomponents;
    _j_wavefunction_index_pointer += 1 * _j_wavefunction_ncomponents;
    
  }
  #undef j
  #undef dj
  #undef dalpha_dt
  #undef dbeta_dt
  #undef alpha
  #undef beta
}

// ********************************************************
//   output function implementations
void _write_output()
{
  _LOG(_SIMULATION_LOG_LEVEL, "Generating output for DDBH_Nsite_PP_v1\n");
  
  
  char *_xsilFilename = (char*)malloc(256);
  snprintf(_xsilFilename, 256, "%s.xsil", ("file_output" + gsArgsAndValues).c_str());
  
  FILE* _outfile = _open_xsil_file(_xsilFilename);
  
  if (_outfile) {
    _write_xsil_header(_outfile);
    char _dataFilename[200];
    snprintf(_dataFilename, 200, "%s.h5", ("file_output" + gsArgsAndValues).c_str());
    
    H5Fclose(H5Fcreate(_dataFilename, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT));
  }
  _mg0_write_out(_outfile);
  
  _write_xsil_footer(_outfile);
  _close_xsil_file(_outfile);
  free(_xsilFilename);
  _xsilFilename = NULL;
  _outfile = NULL;
  
}


FILE* _open_xsil_file(const char* _filename)
{
  
  FILE* fp = fopen(_filename, "w");
  
  if (fp == NULL)
    // _LOG will cause the simulation to exit
    _LOG(_ERROR_LOG_LEVEL, "Unable to open output file '%s'.\n"
                           "Exiting.\n", _filename);
  
  return fp;
}

void _close_xsil_file(FILE*& fp)
{
  if (fp)
    fclose(fp);
  fp = NULL;
  
}

void _write_xsil_header(FILE* fp)
{
  if (!fp)
    return;
  fprintf(fp, "<?xml version=\"1.0\" ?><simulation xmds-version=\"2\">\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <author>\n");
  fprintf(fp, "    A Ferrier\n");
  fprintf(fp, "  </author>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <description>\n");
  fprintf(fp, "    Driven-Dissipative Bose-Hubbard model\n");
  fprintf(fp, "    for N sites in 1 dimensional chain\n");
  fprintf(fp, "    Positive P version\n");
  fprintf(fp, "  </description>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <features>\n");
  fprintf(fp, "    <benchmark/>\n");
  fprintf(fp, "    <bing/>\n");
  fprintf(fp, "    <halt_non_finite/>\n");
  fprintf(fp, "    <auto_vectorise/>\n");
  fprintf(fp, "    <validation kind=\"run-time\"/>\n");
  fprintf(fp, "    <arguments>\n");
  fprintf(fp, "\n");
  fprintf(fp, "      <!-- Numerical Specifications -->\n");
  fprintf(fp, "      <argument default_value=\"100\" name=\"Ttot\" type=\"real\"/>\n");
  fprintf(fp, "      \n");
  fprintf(fp, "      <!-- Number of Sites -->\n");
  fprintf(fp, "      <argument default_value=\"3\" name=\"N\" type=\"integer\"/>\n");
  fprintf(fp, "\n");
  fprintf(fp, "      <!-- Parameter Specifications -->\n");
  fprintf(fp, "      <argument default_value=\"0.5\" name=\"Kappa\" type=\"real\"/>\n");
  fprintf(fp, "      <argument default_value=\"1.5\" name=\"Uint\" type=\"real\"/>\n");
  fprintf(fp, "      <argument default_value=\"-2.0\" name=\"Delta\" type=\"real\"/>\n");
  fprintf(fp, "      <argument default_value=\"1.0\" name=\"Jhop\" type=\"real\"/>\n");
  fprintf(fp, "           \n");
  fprintf(fp, "      <!-- Pump Specifications -->\n");
  fprintf(fp, "      <argument default_value=\"1.0\" name=\"FPmp\" type=\"real\"/>\n");
  fprintf(fp, "\n");
  fprintf(fp, "      <!-- Seeding noise vector. -->\n");
  fprintf(fp, "      <argument default_value=\"8\" name=\"seed1\" type=\"integer\"/>\n");
  fprintf(fp, "      <argument default_value=\"6\" name=\"seed2\" type=\"integer\"/>\n");
  fprintf(fp, "      <argument default_value=\"5\" name=\"seed3\" type=\"integer\"/>\n");
  fprintf(fp, "\n");
  fprintf(fp, "    </arguments>\n");
  fprintf(fp, "  </features> \n");
  fprintf(fp, "\n");
  fprintf(fp, "  <geometry>\n");
  fprintf(fp, "    <propagation_dimension>\n");
  fprintf(fp, "      t\n");
  fprintf(fp, "    </propagation_dimension>\n");
  fprintf(fp, "    <transverse_dimensions>\n");
  fprintf(fp, "      <dimension domain=\"(1,N)\" lattice=\"N\" name=\"j\" type=\"integer\"/>\n");
  fprintf(fp, "    </transverse_dimensions>\n");
  fprintf(fp, "  </geometry>\n");
  fprintf(fp, "\n");
  fprintf(fp, "\n");
  fprintf(fp, "<!-- %%%% Initialise from previous output\n");
  fprintf(fp, "<vector name=\"wavefunction\" type=\"complex\" dimensions=\"\">\n");
  fprintf(fp, "    <components>\n");
  fprintf(fp, "      alpha\n");
  fprintf(fp, "    </components>\n");
  fprintf(fp, "    <initialisation kind=\"hdf5\">\n");
  fprintf(fp, "    <filename>  </filename>\n");
  fprintf(fp, "  </initialisation>\n");
  fprintf(fp, "  </vector>\n");
  fprintf(fp, "%%%%%% -->\n");
  fprintf(fp, "\n");
  fprintf(fp, "<!-- %%%%%%%% Fixed initial state  %%%% -->\n");
  fprintf(fp, "  <vector dimensions=\"j\" name=\"wavefunction\" type=\"complex\">\n");
  fprintf(fp, "    <components>\n");
  fprintf(fp, "      alpha\n");
  fprintf(fp, "      beta\n");
  fprintf(fp, "    </components>\n");
  fprintf(fp, "    <initialisation>\n");
  fprintf(fp, "      <![CDATA[\n");
  fprintf(fp, "        alpha = 0;\n");
  fprintf(fp, "        beta = 0;\n");
  fprintf(fp, "       ]]>\n");
  fprintf(fp, "    </initialisation>\n");
  fprintf(fp, "  </vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "<!--- %%%%%%%%%% Hopping coefficients j -> j+1 and j -> j-1 for each site,\n");
  fprintf(fp, "      can also be used to define boundary conditions.  All = Jhop means uniform hopping on ring (periodic boundaries) -->\n");
  fprintf(fp, "<vector dimensions=\"j\" name=\"hoppings\" type=\"real\">\n");
  fprintf(fp, "    <components>\n");
  fprintf(fp, "      J_hop_plus J_hop_minus\n");
  fprintf(fp, "    </components>\n");
  fprintf(fp, "    <initialisation>\n");
  fprintf(fp, "      <![CDATA[\n");
  fprintf(fp, "        J_hop_plus = Jhop;\n");
  fprintf(fp, "        J_hop_minus = Jhop;\n");
  fprintf(fp, "       ]]>\n");
  fprintf(fp, "    </initialisation>\n");
  fprintf(fp, "  </vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <noise_vector dimensions=\"j\" kind=\"wiener\" method=\"dsfmt\" name=\"QNoise\" seed=\"seed1 seed2 seed3\" type=\"real\">\n");
  fprintf(fp, "    <components>\n");
  fprintf(fp, "      XiA\n");
  fprintf(fp, "      XiB\n");
  fprintf(fp, "    </components>\n");
  fprintf(fp, "  </noise_vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <sequence>\n");
  fprintf(fp, "    <integrate algorithm=\"RK4\" interval=\"Ttot\" steps=\"100000\">\n");
  fprintf(fp, "      <samples>\n");
  fprintf(fp, "        1000\n");
  fprintf(fp, "      </samples>     \n");
  fprintf(fp, "\n");
  fprintf(fp, "      <operators>\n");
  fprintf(fp, "\n");
  fprintf(fp, "        <dependencies>\n");
  fprintf(fp, "          QNoise hoppings\n");
  fprintf(fp, "        </dependencies>\n");
  fprintf(fp, "\n");
  fprintf(fp, "        <integration_vectors>\n");
  fprintf(fp, "          wavefunction\n");
  fprintf(fp, "        </integration_vectors>\n");
  fprintf(fp, " \n");
  fprintf(fp, "        <![CDATA[                                                                        \n");
  fprintf(fp, "          int j_plus = (j%%N) + 1;\n");
  fprintf(fp, "          int j_minus = N - (N+1-j)%%N;\n");
  fprintf(fp, "          \n");
  fprintf(fp, "          dalpha_dt(j => j) = i*Delta*alpha(j => j) -Kappa*alpha(j => j) -i*Uint*alpha(j => j)*beta(j => j)*alpha(j => j) +0.5*i*Uint*alpha(j => j) \n");
  fprintf(fp, "                +i*J_hop_plus(j => j)*alpha(j => j_plus) +i*J_hop_minus(j => j)*alpha(j => j_minus) -i*FPmp +sqrt(i*Uint)*i*alpha(j => j)*XiA(j => j);\n");
  fprintf(fp, "\n");
  fprintf(fp, "          dbeta_dt(j => j) = -i*Delta*beta(j => j) -Kappa*beta(j => j) +i*Uint*beta(j => j)*alpha(j => j)*beta(j => j) -0.5*i*Uint*beta(j => j) \n");
  fprintf(fp, "                -i*J_hop_plus(j => j)*beta(j => j_plus) -i*J_hop_minus(j => j)*beta(j => j_minus) +i*FPmp +sqrt(i*Uint)*beta(j => j)*XiB(j => j);\n");
  fprintf(fp, "        ]]>\n");
  fprintf(fp, "      </operators>\n");
  fprintf(fp, "\n");
  fprintf(fp, "    </integrate>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  </sequence>\n");
  fprintf(fp, "\n");
  fprintf(fp, "<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%% Alex's Saving data %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <output filename=\"file_output.xsil\" format=\"hdf5\">\n");
  fprintf(fp, "    <sampling_group basis=\"j\" initial_sample=\"yes\">\n");
  fprintf(fp, "      <dependencies>\n");
  fprintf(fp, "        wavefunction\n");
  fprintf(fp, "      </dependencies>\n");
  fprintf(fp, "      <moments>\n");
  fprintf(fp, "        alphaR\n");
  fprintf(fp, "        alphaI\n");
  fprintf(fp, "        betaR\n");
  fprintf(fp, "        betaI\n");
  fprintf(fp, "      </moments>\n");
  fprintf(fp, "      <![CDATA[\n");
  fprintf(fp, "        _SAMPLE_COMPLEX(alpha);\n");
  fprintf(fp, "        _SAMPLE_COMPLEX(beta);\n");
  fprintf(fp, "      ]]>\n");
  fprintf(fp, "    </sampling_group>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  </output>\n");
  fprintf(fp, "\n");
  
  fprintf(fp, "\n<info>\n");
  fprintf(fp, "Script compiled with XMDS2 version 3.0.0 \"Release the Kraken\" (r3072)\n");
  fprintf(fp, "See http://www.xmds.org for more information.\n");
  fprintf(fp, "\nVariables that can be specified on the command line:\n");
  
  fprintf(fp, "  Command line argument Ttot = %e\n", Ttot);
  
  fprintf(fp, "  Command line argument N = %li\n", N);
  
  fprintf(fp, "  Command line argument Kappa = %e\n", Kappa);
  
  fprintf(fp, "  Command line argument Uint = %e\n", Uint);
  
  fprintf(fp, "  Command line argument Delta = %e\n", Delta);
  
  fprintf(fp, "  Command line argument Jhop = %e\n", Jhop);
  
  fprintf(fp, "  Command line argument FPmp = %e\n", FPmp);
  
  fprintf(fp, "  Command line argument seed1 = %li\n", seed1);
  
  fprintf(fp, "  Command line argument seed2 = %li\n", seed2);
  
  fprintf(fp, "  Command line argument seed3 = %li\n", seed3);
  fprintf(fp, "</info>\n");
  
}

// In addition to writing the footer (if 'fp' is not NULL)
// this function closes the fp file pointer.
void _write_xsil_footer(FILE* fp)
{
  if (fp) {
    fprintf(fp, "</simulation>\n");
  }
}

// ********************************************************
//   moment group 0 function implementations
void _mg0_sample()
{
  
  long _mg0_output_raw_index_pointer = 0;
  #define alphaR _active_mg0_output_raw[_mg0_output_raw_index_pointer + 0]
  #define alphaI _active_mg0_output_raw[_mg0_output_raw_index_pointer + 1]
  #define betaR _active_mg0_output_raw[_mg0_output_raw_index_pointer + 2]
  #define betaI _active_mg0_output_raw[_mg0_output_raw_index_pointer + 3]
  long _j_wavefunction_index_pointer = 0;
  #define alpha _active_j_wavefunction[_j_wavefunction_index_pointer + 0]
  #define beta _active_j_wavefunction[_j_wavefunction_index_pointer + 1]
  #define j _j[_index_j + 0]
  #define dj (_dj * (1.0))
  
  for (long _index_j = 0; _index_j < _lattice_j; _index_j++) {
    // Set index pointers explicitly for (some) vectors
    _mg0_output_raw_index_pointer = ( 0
       + _mg0_output_index_t  * _lattice_j
       + _index_j * 1 ) * _mg0_output_raw_ncomponents;
    #define _SAMPLE_COMPLEX(variable) \
              variable ## R = variable.Re(); variable ## I = variable.Im();
    
    // *************** Sampling code ****************
    #line 146 "DDBH_Nsite_PP_v1.xmds"
    
    _SAMPLE_COMPLEX(alpha);
    _SAMPLE_COMPLEX(beta);
    
    #line 1378 "DDBH_Nsite_PP_v1.cc"
    // **********************************************
    
    #undef _SAMPLE_COMPLEX
    // Increment index pointers for vectors in field mg0_sampling (or having the same dimensions)
    _j_wavefunction_index_pointer += 1 * _j_wavefunction_ncomponents;
    
  }
  #undef j
  #undef dj
  #undef alphaR
  #undef alphaI
  #undef betaR
  #undef betaI
  #undef alpha
  #undef beta
  
  _mg0_output_t[0 + _mg0_output_index_t++] = t;
  
  _LOG(_SAMPLE_LOG_LEVEL, "Sampled field (for moment group #1) at t = %e\n", t);
  
}


void _mg0_process()
{
  // No post processing needs to be done
}


void _mg0_write_out(FILE* _outfile)
{
  
  if (_outfile) {
    fprintf(_outfile, "\n");
    fprintf(_outfile, "<XSIL Name=\"moment_group_1\">\n");
    fprintf(_outfile, "  <Param Name=\"n_independent\">2</Param>\n");
    fprintf(_outfile, "  <Array Name=\"variables\" Type=\"Text\">\n");
    fprintf(_outfile, "    <Dim>6</Dim>\n");
    fprintf(_outfile, "    <Stream><Metalink Format=\"Text\" Delimiter=\" \\n\"/>\n");
    fprintf(_outfile, "t j alphaR alphaI betaR betaI \n");
    fprintf(_outfile, "    </Stream>\n");
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "  <Array Name=\"data\" Type=\"double\">\n");
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _mg0_output_lattice_t);
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _lattice_j);
    fprintf(_outfile, "    <Dim>6</Dim>\n");
  }
  
  
  char _h5Filename[200];
  snprintf(_h5Filename, 200, "%s.h5", ("file_output" + gsArgsAndValues).c_str());
  
  /* Open the file */
  hid_t hdf5_file = H5Fopen(_h5Filename, H5F_ACC_RDWR, H5P_DEFAULT);
  if (hdf5_file < 0) {
    _LOG(_WARNING_LOG_LEVEL, "Failed to open HDF5 file '%s', will try to create it.", _h5Filename);
    hdf5_file = H5Fcreate(_h5Filename, H5F_ACC_EXCL, H5P_DEFAULT, H5P_DEFAULT);
    if (hdf5_file < 0) {
      _LOG(_ERROR_LOG_LEVEL, "Failed to create HDF5 file '%s'. Bailing.", _h5Filename);
    }
  }
  
  /* Create the group for this data */
  hid_t group;
  if (!H5Lexists(hdf5_file, "/1", H5P_DEFAULT))
    group = H5Gcreate(hdf5_file, "/1", H5P_DEFAULT);
  else
    group = H5Gopen(hdf5_file, "/1");
  
  if (_outfile) {
    fprintf(_outfile, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/1\"/>\n");
    fprintf(_outfile, "%s.h5\n", ("file_output" + gsArgsAndValues).c_str());
    fprintf(_outfile, "    </Stream>\n");
  }
  
  /* Create the coordinate data sets */
  hsize_t coordinate_length;
  hid_t coordinate_dataspace;
  coordinate_length = _mg0_output_lattice_t;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_t;
  if (!H5Lexists(hdf5_file, "/1/t", H5P_DEFAULT))
    dataset_t = H5Dcreate(hdf5_file, "/1/t", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_t = H5Dopen(hdf5_file, "/1/t");
  H5Dwrite(dataset_t, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _mg0_output_t);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_t, "t");
  #endif
  
  H5Sclose(coordinate_dataspace);
  coordinate_length = _lattice_j;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_j;
  if (!H5Lexists(hdf5_file, "/1/j", H5P_DEFAULT))
    dataset_j = H5Dcreate(hdf5_file, "/1/j", H5T_NATIVE_LONG, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_j = H5Dopen(hdf5_file, "/1/j");
  H5Dwrite(dataset_j, H5T_NATIVE_LONG, H5S_ALL, H5S_ALL, H5P_DEFAULT, _j);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_j, "j");
  #endif
  
  H5Sclose(coordinate_dataspace);
  
  hsize_t file_dims[] = {_mg0_output_lattice_t, _lattice_j};
  hid_t file_dataspace = H5Screate_simple(2, file_dims, NULL);
  
  hid_t dataset_alphaR;
  if (!H5Lexists(hdf5_file, "/1/alphaR", H5P_DEFAULT))
    dataset_alphaR = H5Dcreate(hdf5_file, "/1/alphaR", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_alphaR = H5Dopen(hdf5_file, "/1/alphaR");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_alphaR, dataset_t, 0);
    H5DSattach_scale(dataset_alphaR, dataset_j, 1);
  #endif
  hid_t dataset_alphaI;
  if (!H5Lexists(hdf5_file, "/1/alphaI", H5P_DEFAULT))
    dataset_alphaI = H5Dcreate(hdf5_file, "/1/alphaI", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_alphaI = H5Dopen(hdf5_file, "/1/alphaI");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_alphaI, dataset_t, 0);
    H5DSattach_scale(dataset_alphaI, dataset_j, 1);
  #endif
  hid_t dataset_betaR;
  if (!H5Lexists(hdf5_file, "/1/betaR", H5P_DEFAULT))
    dataset_betaR = H5Dcreate(hdf5_file, "/1/betaR", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_betaR = H5Dopen(hdf5_file, "/1/betaR");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_betaR, dataset_t, 0);
    H5DSattach_scale(dataset_betaR, dataset_j, 1);
  #endif
  hid_t dataset_betaI;
  if (!H5Lexists(hdf5_file, "/1/betaI", H5P_DEFAULT))
    dataset_betaI = H5Dcreate(hdf5_file, "/1/betaI", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_betaI = H5Dopen(hdf5_file, "/1/betaI");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_betaI, dataset_t, 0);
    H5DSattach_scale(dataset_betaI, dataset_j, 1);
  #endif
  H5Dclose(dataset_t);
  H5Dclose(dataset_j);
  
  
  if ((_mg0_output_lattice_t * _lattice_j)) {
    /* Create the data space */
    hsize_t file_start[2] = {(unsigned long long int)0, (unsigned long long int)0};
    hsize_t mem_dims[3] = {(unsigned long long int)_mg0_output_lattice_t, (unsigned long long int)_lattice_j, (unsigned long long int)1};
    hsize_t mem_start[3] = {0, 0, 0};
    hsize_t mem_stride[3] = {1, 1, 1};
    hsize_t mem_count[3] = {(unsigned long long int)_mg0_output_lattice_t, (unsigned long long int)_lattice_j, (unsigned long long int)1};
    
    
    hid_t mem_dataspace;
    mem_dims[2] = 4;
    mem_dataspace = H5Screate_simple(3, mem_dims, NULL);
    mem_stride[2] = 4;
    
    // Select hyperslabs of memory and file data spaces for data transfer operation
    mem_start[2] = 0;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_alphaR)
      H5Dwrite(dataset_alphaR, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_raw);
    mem_start[2] = 1;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_alphaI)
      H5Dwrite(dataset_alphaI, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_raw);
    mem_start[2] = 2;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_betaR)
      H5Dwrite(dataset_betaR, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_raw);
    mem_start[2] = 3;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_betaI)
      H5Dwrite(dataset_betaI, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_raw);
    
    H5Sclose(mem_dataspace);
  }
  
  
  H5Dclose(dataset_alphaR);
  H5Dclose(dataset_alphaI);
  H5Dclose(dataset_betaR);
  H5Dclose(dataset_betaI);
  
  H5Sclose(file_dataspace);
  H5Gclose(group);
  H5Fclose(hdf5_file);
  
  
  if (_outfile) {
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "</XSIL>\n");
  }
}

// ********************************************************
//   field mg0_output function implementations
// initialisation for vector raw
void _mg0_output_raw_initialise()
{
  
  bzero(_active_mg0_output_raw, sizeof(real) * _mg0_output_raw_alloc_size);
}

